#! /usr/bin/env python3

"""
Script to diff old and new BAMQC JSON outputs, generated by bamqc.pl and bam_qc.py respectively

JSON data structure has changed; maps old fields to new fields, and disregards obsolete or uncomparable ones
"""

import argparse, json, re, statistics, sys

class diff:

    NUMERIC_FIELDS = ['deleted bases', 'hard clip bases', 'inserted bases', 'mapped reads', 'non primary reads', 'number of targets', 'paired reads', 'pairsMappedAbnormallyFar', 'pairsMappedToDifferentChr', 'properly paired reads', 'qual fail reads', 'read 1 average length', 'read 2 average length', 'read ? average length', 'reads per start point', 'readsMissingMDtags', 'soft clip bases', 'total reads', 'unmapped reads']
    DICTIONARY_FIELDS = ['read 1 deletion by cycle', 'read 1 hard clip by cycle', 'read 1 insertion by cycle', 'read 1 mismatch by cycle', 'read 1 soft clip by cycle', 'read 2 deletion by cycle', 'read 2 hard clip by cycle', 'read 2 insertion by cycle', 'read 2 mismatch by cycle', 'read 2 soft clip by cycle', 'read ? deletion by cycle', 'read ? hard clip by cycle', 'read ? insertion by cycle', 'read ? mismatch by cycle', 'read ? soft clip by cycle']
    # TODO compare 'mark duplicates'
    STRING_TO_INT = ['mapped reads', 'non primary reads', 'number of targets', 'pairsMappedAbnormallyFar', 'pairsMappedToDifferentChr', 'qual fail reads', 'readsMissingMDtags', 'unmapped reads']
    STRING_TO_FLOAT = ['reads per start point', 'insert size average', 'insert stdev', 'insert mean']
    
    KEY_MAP = {
        'bases mapped': 'aligned bases',
        'insert size average': 'insert mean',
        'insert size standard deviation': 'insert stdev',
        'mismatched bases': 'mismatch bases',
        'reads mapped and paired': 'mate unmapped reads',
        'total target size': 'target size'
    }
    
    def __init__(self):
        pass

    def compare_data(self, old_data, new_data):
        comparison = {}
        for key in self.NUMERIC_FIELDS:
            if key in self.STRING_TO_INT: old_val = int(old_data[key])
            elif key in self.STRING_TO_FLOAT: old_val = float(old_data[key])
            else: old_val = old_data[key]
            new_val = new_data[key]
            #print(key, [old_data[key], new_data[key]])
            if new_val == None: gain = None
            else: gain = new_val - old_val
            result = {
                'old': old_val,
                'new': new_data[key],
                'gain': gain
            }
            comparison[key] = result
        for j in self.DICTIONARY_FIELDS:
            result = {}
            result['old'] = old_data[j]
            result['new'] = new_data[j]
            old_key_set = set(old_data[j].keys())
            new_key_set = set(old_data[j].keys())
            result['old keys not in new'] = list(old_key_set - new_key_set)
            result['new keys not in old'] = list(new_key_set - old_key_set)
            gain = []
            shared_keys = list(old_key_set.union(new_key_set))
            result['shared keys'] = shared_keys
            #print(j, old_data[j])
            for k in shared_keys:
                gain.append(new_data[j][k] - old_data[j][k])
            if len(gain) > 0:
                result['min gain'] = min(gain)
                result['max gain'] = max(gain)
                result['mean gain'] = statistics.mean(gain)
                result['median gain'] = statistics.median(gain)
            else:
                result['min gain'] = None
                result['max gain'] = None
                result['mean gain'] = None
                result['median gain'] = None
            comparison[j] = result
        for key in self.KEY_MAP.keys():
            old_key = self.KEY_MAP[key]
            #print(key, old_key, [new_data[key], old_data[old_key]])
            if old_key in self.STRING_TO_FLOAT: old_val = float(old_data[old_key])
            else: old_val = old_data[old_key]
            result = {
                'old': old_val,
                'new': new_data[key],
                'gain': new_data[key] - old_val
            }
            comparison[key] = result
        key = 'average read length'
        new_val = new_data[key]
        old_val = int(round(float(old_data[key]), 0))
        result = {
            'old': old_data[old_key],
            'new': new_data[key],
            'gain': new_data[key] - old_val
        }
        comparison[key] = result
        return comparison
            
    def compare_paths(self, old_path, new_path):
        old_data = json.loads(open(old_path).read())
        new_data = json.loads(open(new_path).read())
        return self.compare_data(old_data, new_data)
    
    def print_comparison(self, old_path, new_path):
        comparison = self.compare_paths(old_path, new_path)
        print(json.dumps(comparison))
    
        
def main():
    parser = argparse.ArgumentParser(description='Diff for old and new BAMQC JSON files. Writes JSON to STDOUT.')
    parser.add_argument('-n', '--new', metavar='PATH', required=True,
                        help='Path to new-format input JSON file. Required.')
    parser.add_argument('-o', '--old', metavar='PATH', required=True,
                        help='Path to old-format input JSON file. Required.')
    args = parser.parse_args()
    diff().print_comparison(args.old, args.new)


if __name__ == "__main__":
    main()
